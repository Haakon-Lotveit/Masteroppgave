# Resultater #

## AuRa i fire deler ##

Hovedmålet var å produsere en artefakt som kan fungere som en start på en diskusjon om hvordan vi kan ha standardiserte åpne løsninger på produksjon av rapporter, og hvordan dette kan gjøres enklere, bedre og rimeligere enn i dag. I så måte har AuRa vært et verktøy for å uttrykke et syn på en mulig løsning.

AuRa er bygget opp i fire deler. Det er et språk for å definere inndatakildene til en rapport, en frontendkompilator som kompilerer kildene ned til et mellomformat, og så til slutt en backendkompilator som kompilerer det hele ned til et valgt utformat.
Denne oppbygningen gir programmet en fleksibilitet som lar det takle forskjellige arbeidsoppgaver, og gjør det enkelt å utvide systemet til å takle nye utfordringer.

## Valg av støttede formater ##

Det er valgt ut tre formater som skulle støttes, som ble ansett som et minstemål for å ha et levedyktig system som kunne være reelt nyttig for folk.

Disse tre er:

 - Markdown, som lar en skrive formattert tekst på en enkel måte
 - CSV, som lar en legge til tabulære data
 - PNG, som lar en bruke bilder i rapportene sine.

Tanken var å produsere rapporter basert på data fra disse tre kildene. Årsaken til at disse tre ble valgt var følgende:

### Markdown ###
Markdown ble valgt fordi det blir brukt på populære sider som [StackOverflow](http://stackoverflow.com/editing-help) og [GitHub](https://help.github.com/articles/github-flavored-markdown/) og enterpriseverktøy som tilbys av Atlassian som [Confluence, Stash og Jira](https://confluence.atlassian.com/display/STASH/Markdown+syntax+guide) (riktignok med egne utvidelser), og er dermed mer sannsynlig at folk har sett før. I tillegg er språket enkelt å begynne å bruke. En kunne ha argumentert for å bruke filer fra MS Word eller lignende, men dette ble ansett som for vanskelig å få til med tiden som var tilgjengelig. Markdown er dessuten et tekstbasert språk, og en kan dermed åpne og redigere det i en vanlig teksteditor som Notepad, gedit eller Text Edit. En kan også bruke mer avanserte editorer som GNU Emacs, Sublime Edit eller lignende dersom en ønsker det.

Utfordringen kom i at Markdown ikke har god dokumentasjon. Den har [en guide](http://daringfireball.net/projects/markdown/syntax), men ingen formell syntaks tilgjengelig på hjemmesiden. Den tilbyr [en referanseimplementasjon](http://daringfireball.net/projects/markdown/) skrevet i perl, levert i en fil, med 1450 linjer kode. Selv om koden var god og idiomatisk perl, er det likevel noe meget for en person å sette seg ned å lese og forstå. Parsing og kompilering av markdown endte opp til slutt med å være den største tidstyven, og det tok flere måneder før en korrekt implementasjon var på plass. Når det er sagt, må det også sies at Markdown ikke ble et populært språk ved å være dårlig. I likhet med dette prosjektet tar det også sikte på å være så leselig som mulig[Markdown-referanse til lesbarhet](http://daringfireball.net/projects/markdown/), som er en av grunnene til at det ble valgt som første støttede tekstspråk.

### CSV ###
CSV ble valgt av flere grunner. For det første er det et lingua franca hva angår tabeller. En kan eksportere til CSV fra regneark som Excel[excel-csv](https://support.office.com/en-za/article/Import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba) eller Calc[calc-csv](https://help.libreoffice.org/Calc/Importing_and_Exporting_CSV_Files), samt fra SQL-verktøy som DBVisualiser[dbvis-csv](http://www.dbvis.com/doc/9.0/doc/ug/exportImport/exportImport.html), eller direkte fra programmeringsspråk som Java, Common Lisp, C#, C++, Haskell, m.fl. At formatet er så universelt gjør det til et selvsagt valg for håndtering av tabeller: En kan alltids gjøre om til CSV fra andre tabellformater, og dermed kan en for eksempel bruke MS Excel til datamanipulering, og så eksportere til CSV, og deretter bruke resultatet nesten direkte i AuRa. I tillegg tilbyr LibreOffice[lo-ask-odt-csv](http://ask.libreoffice.org/en/question/21916/cli-convert-ods-to-csv-with-semicolon-as-delimiter/) muligheter for å skripte konverteringen så en kan gjøre det via skript før en kjører AuRa.


### Bilder ###
Det er ikke noe offisielt bildeformat som støttes, selv om det eneste som er omstendelig testet er PNG (Portable Network Graphics). Behovet for bilder bygger på flere årsaker:

 - De fleste større tekststykker har bilder i seg for å bryte opp teksten.
 - Grafer og diagrammer er en naturlig del av rapportering.
 - LaTeX og andre formater støtter kompilering av matematiske formler ned til bildeformater

Dermed, for å støtte disse behovene, ikke bare for generelle bilder, men også diagrammer formler og grafer, ble det implementert støtte for bilder. Denne støtten er den programmatiske enkleste å støtte, og den første som ble gjennomtestet og ferdig.

## Prosjektfilen (.AuRa) ##

Prosjektfilen i seg selv er ganske enkel. Tomme linjer blir ignorert, og kommentarer begynner med semikolon (;) og går til slutten av linjen.
Hver spesifikasjon begynner med en åpen parantes, med type av inndata som en streng, og deretter blir opsjonenene gitt. Opsjoner begynner alltid med et kolon og blir umiddelbart etterfulgt av en strenginstans. For eksempel:

        (markdown :fil "~/git/Masteroppgave/oppgaven/bakgrunn.markdown")

(Dette eksempelet er tatt fra filen som ble brukt til å generere denne oppgaven.)

Mer formelt vil gyldige utsagn alltid ta formen (Utvidet Backus-Naur Form):
        ws = \[:whitespace:\]
        gyldig navn = :char:-ws;
        datakilde = gyldig navn ;
        opsjonsnavn = gyldig navn ;
        linje = \[ws\], \[datakilde\], \[ws\], \[kommentar\]
        kommentar = ";", [:character:] ;
        datakilde = "(", navn, {opsjonsgruppe}, \[ws\]")" ;
        escape hermetegn = "\\"" ;
        strengliteral = "\"" {:char:-"\"" | escape hermetegn} "\"" ;
        opsjonsgruppe = ws ":", gyldig navn, ws, strengliteral ;

Per dags dato kan en anse grammatikken som betydelig forenklet med bare følgende lovlige utsagn:
        escape hermetegn = "\\"" ;
        strengliteral    = "\"" {:char:-"\"" | escape hermetegn} "\"" ;
		kommentar        = ";", [:character:] ;
        markdown         = "(markdown :fil ", strengliteral, [:whitespace:], ")" ;
        bilde            = "(bilde :fil ", strengliteral, [:whitespace:], ")" ;
        tabell           = (tabell :fil ", strengliteral, [:whitespace:], [":første-linje-er-tabellnavn ", ("ja"|"nei")], ")" ;
		linje            = [:whitespace:], [tabell | bilde | markdown], [:whitespace:], [kommentar] ;
Men poenget forblir det samme: Grammatikken er svært enkel å forstå for tredjepersoner. Den er med vilje designet for å være lettere å lese enn for å være rask å skrive. 
Grunnen til at dette valget ble tatt tidlig i prosjektet er hentet fra The Mythical Man Month§MythicalManMonth§ der det blir hevdet at over 90% av alle kostnadene ved et programvareprosjekt kommer når en skal vedlikeholde det. Dermed er det mer økonomisk å gjøre det lett for programmerere å vedlikeholde et system, enn det er å gjøre det raskt å skrive. Som en konsekvens av dette blir alle kilder spesifisert spesifikt for seg en per linje, så det er enkelt å se hvor alle kildene kommer fra. Som en direkte konsekvens av dette er for eksempel bilder en egen datakilde, og spesifiseres for seg selv, selv om den kan spesifiseres internt i til dømes Markdown. Det har den uheldige konsekvensen at dersom en ønsker å putte et bilde i en tekstbolk må teksten splittes i to filer. En før og en etter teksten. Det finnes dog måter å komme rundt dette irritasjonsmomentet:

 - En kan utvide inndatafilen til å kunne ta i mot tekst som sitater, uten å referere til eksterne filer der teksten er enkel og relativt kort. Dette vil minimere bryet med å peke til filer. En siterer tekst, avslutter tekstbolken, setter inn et bilde, og fortsetter på en ny tekstbolk.
 - En kan også skrive verktøy som genererer AuRa filen automatisk mens du skriver for deg. Et slikt verktøy vil kunne splitte opp filer uten at du som produsent av rapporten må bry deg om de eksakte detaljene. En kan tenke seg standardiserte filnavn og undermapper som kan genereres maskinelt for å holde orden på teksten.

Slike irritasjonsmomenter er uheldige, men de er et valg som er tatt for å gjøre det enklere å senere gå igjennom en rapport for å plukke ut filer og oppdatere dem manuelt. Dersom for eksempel bilder ble spesifisert i et dokument blir det med ett mer komplisert å søke gjennom dem for å finne bildene og hvor de spesifiseres. Dette gjelder selvsagt også dersom en spesifiserer tabeller i et tekstformat for senere å finne dem.

Ved å holde slik informasjon i en sentral fil blir det enklere å søke igjennom dem, og holde orden på dem.

## Kompilering av AuRa filen, eller evt. Frontendkompilatoren ##

Frontendkompilatoren vil kompilere kildene beskrevet i .aura-filen ned til et mellomformat som er kalt "mfo"¤kort for *m*ellom*fo*rmat¤.

Dette mellomformatet er inspirert av Lisp og LaTeX-kommandoer. I all hovedsak blir tekst behandlet slik:

 - Backendkompilatoren behandler enten vanlig tekst eller en kommando.
 - Kommandoer blir behandlet for seg uten å vite om konteksten til resten av dokumentet.
 - Kommandoer blir begynt med en åpen parentes, og avsluttet med en lukket parentes.
 - Frontendparseren vil "escape" vanlige parenteser som ikke signaliserer en kommando med et '\' tegn.
 - Kommandoene kan ta i mot opsjonsgrupper som er grammatisk like AuRa, men etterfølges av tegn.

Merk at indentering ikke er meningsbærende i dette språket, og selv om det er ment til å være relativt lettlest for mennesker er det først og fremst et språk som er enkelt å parse ut og behandle maskinelt. Dette gjør det lettere å støtte nye utdataformater ved å lage nye plug-ins for backendkompilatoren. Siden det er bare et språk en må kunne parse, uavhengig av hvilke inndataformater som støttes, blir arbeidsbyrden mindre. En introduserer en ekstra byrde når en vil utvide mellomformatet, men denne byrden ville vært like stor uansett om en hadde et slikt format eller ikke.

Slik frontendkompilatoren er skrevet i dag vil den ta for seg AuRa-filen sekvensielt. Det vil si at den tar en og en datakilde, kompilerer den til mfo, og skriver til disk, før den går videre til neste. Dette er relativt raskt på små rapporter som denne, men dersom det viser seg å være ineffektivt, er dette et sted en kan tenke seg paralellisering for å øke hastigheten. En kan også optimalisere hastigheten ved å ikke skrive til disk, men lagre mellomformatet i minnet, da diskaksess er tregere enn minneaksess. Eksekusjonshastighet har dog ikke vært et fokus i dette prosjektet, ren kode, testdekning og kompletthet har vært større og viktigere fokus enn hastighet.

Slik det står i dag er mellomformatet skrevet til disk for å kunne lettere feilrette evt. feil som måtte dukke opp, og for å gjøre det så enkelt som mulig for enhetstesting. Ved en senere iterasjon kan en gå over til andre måter å ha enhetstesting på, men slik det er i dag fungerer korrekt.

## Mellomformatet ##

For eksempel kan en ta denne teksten (basert på kompileringen av oppgaven, forkortet):
        (NEW-PARAGRAPH)
        (UNORDERED-LIST
        (LINE-ITEM Språket er med vilje holdt enkelt. (...) )
        (LINE-ITEM Språket velger alltid (...) )
        (LINE-ITEM Språket er valgt til å (...) )
        (LINE-ITEM Språket vil beskrive hver (...) )
        (LINE-ITEM Rammeverket vil også legge opp til å (...) )
        (LINE-ITEM Rammeverket legger opp til (...) ))
        (NEW-PARAGRAPH)
        Et annen type problem er utdataformater.
		(...)

Mer formelt kan en beskrive formatet slik (EBNF):

        tekst = {(:char: - "(" - ")") | ("\\", :char:)} ;
        strengliteral = "\"", {(:char: - "\"") | ("\\", :char:)}, "\"" ;
        
        kommando = nullær kommando | tekst kommando | opsjonskommando | topprekursiv kommando ;
        nullær kommando = ny paragraf | horisontal linje ;
        ny paragraf = "\n(NEW-PARAGRAPH)\n" ;
        horisontal linje = "\n(HORISONTAL-LINE)\n" ;
        
        tekstkommando = understreket | emph | kursiv | sitat | sitering ;
        understreket = "(UNDERLINE ", tekst, ")" ;
        kursiv = "(CURSIVE ", tekst ")" ;
        emph = "(EMPHASISED ", tekst ")" ;
        sitat = "(QUOTE ", tekst ")" ;
        sitering = "(CITE ", tekst, ")" ;
        
        opsjonskommando = bilde | url kommando | overskrift ;
        bilde = "(IMAGE :FILE ", streng, ")" ;
        overskrift = "(HEADLINE ", nivå, tekst, ")" ;
        nivå = ":LEVEL ", strengliteral heltall ;
        strengliteral heltall = "\"" :integer: "\"" ;
        
        url kommando = "(URL", navn, altnavn, url, ")" | 
            	       "(URL", navn, url, altnavn, ")" |
        	       "(URL", altnavn, navn, url, ")" | 
        	       "(URL", altnavn, url, navn, ")" |
        	       "(URL", url, altnavn, navn, ")" |
        	       "(URL", url, navn, altnavn, ")" ;
        navn = " :NAME ", strengliteral ;
        altnavn = " :ALT-NAME ", strengliteral ;
        url = " :URL ", strengliteral ;
        
        topprekursiv kommando = liste | tabell ; 
        liste = uliste | oliste
        uliste = "(UNORDERED-LIST", {listeelement}, ")" ;
        oliste = "(ORDERED-LIST", {llisteelement}, ")" ;
        listeelement = "\n(LINE-ITEM ", tekst, ")" ;
        
        tabell = tabell uten header | tabell med header ;
        tabell uten header = "(TABLE", size, "\n", {datarad}, ")" ;
        tabell med header = "(TABLE", størrelse, ":HEADERS \"yes\"\n", overskriftsrad, {datarad}, ")" |
               	   	    "(TABLE", ":HEADERS \"yes\"", størrelse, "\n", overskriftsrad, {datarad}, ")" ;
        rad = datarad | overskriftsrad ;
        datarad = "(ROW", {data}, ")\n" ;
        data = "(DATA ", tekst, ")" ;
        overskriftsrad = "(ROW ", {overskrift}, ")" ;
        overskrift = " (HEADER ", tekst, ")" ;
### Utfordringer ###

